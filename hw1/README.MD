
|Размер сетки|Время алгоритма 11.1(ms)|Время алгоритма 11.2(ms)|Время алгоритма 11.6(ms)|
|---|---|---|---|
|100|1.54425e+06|4.66393e+08|3.97732e+06|
|200|2.00163e+07||2.33703e+07|
|300|9.08067e+07||6.34974e+07|
|400|2.68007e+08||1.45512e+08|
|500|6.28783e+08||3.97879e+08|

Замеры были произведены на процессоре amd ryzen 7 4800h, на восьми потоках.

Можно сделать вывод, что корректно реализованная версия алгоритма начинает быстрее работать с ростом размера сетки. Выигрыш в скороти наступает лишь с какого-то момента и не пропорционален количеству потоков по причине необходимости взаимодействия потоков. Грубо говоря мы быстрее выполняем определенные блоки программы, но платим за это необходимотью синхронизации, переключения и другого взаимодейтвия потоков. То есть получается некий трейдоф, но если блоки кода которые выполняются параллельно дотаточно большие, то использование параллелизма выгодно. Плата становится ообенно большой, если параллельные вычисления организованы не эффективно, этот эффект ярко отражает инференс алгоритма 11.2, где в связи с неоптимальнотью реализации параллелизма, взаимодейвий между потоками больше, вследвие чего алгоритм работает гораздо медленне последовательной версии.

P.S.

Не успел досчитать инференс алгоритма 11.2.
Давайте поверим, что он и для больших n из таблицы медленее работает)